(function() {
  var ColorVariablesParsing, Mixin, Q, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Mixin = require('mixto');

  Q = require('q');

  module.exports = ColorVariablesParsing = (function(_super) {
    __extends(ColorVariablesParsing, _super);

    function ColorVariablesParsing() {
      _ref = ColorVariablesParsing.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    ColorVariablesParsing.variableExpressions = {};

    ColorVariablesParsing.addVariableExpression = function(name, regexp, block) {
      return this.variableExpressions[name] = {
        regexp: regexp,
        block: block
      };
    };

    ColorVariablesParsing.removeVariableExpression = function(name) {
      return delete this.variableExpressions[name];
    };

    ColorVariablesParsing.scanBufferForVariables = function(buffer, callback) {
      return this.scanBufferForVariablesInRange(buffer, [[0, 0], [Infinity, Infinity]], callback);
    };

    ColorVariablesParsing.scanBufferForVariablesInRange = function(buffer, range, callback) {
      var Range, bufferEnd, bufferStart, bufferText, hasResults, lastIndex, match, re, res, results, solver, startIndex,
        _this = this;
      if (buffer == null) {
        throw new Error('Missing buffer');
      }
      Range = buffer.constructor.Range;
      range = Range.fromObject(range);
      hasResults = false;
      bufferStart = buffer.characterIndexForPosition(range.start);
      bufferEnd = buffer.characterIndexForPosition(range.end);
      bufferText = buffer.getText().slice(bufferStart, +bufferEnd + 1 || 9e9);
      re = this.getVariableExpressionsRegexp();
      results = {};
      solver = {
        appendResult: function(_arg) {
          var end, key, lastIndex, start, startIndex, value;
          key = _arg[0], value = _arg[1], startIndex = _arg[2], lastIndex = _arg[3];
          start = buffer.positionForCharacterIndex(startIndex);
          end = buffer.positionForCharacterIndex(lastIndex);
          range = [[start.row, start.column], [end.row, end.column]];
          if (_this.canHandle(value) || ((results[value] != null) && results[value].isColor)) {
            results[key] = {
              value: value,
              range: range,
              isColor: true
            };
            return typeof callback === "function" ? callback(match) : void 0;
          } else {
            results[key] = {
              value: value,
              range: range,
              isColor: false
            };
            return typeof callback === "function" ? callback(match) : void 0;
          }
        }
      };
      re.lastIndex = bufferStart;
      while (match = re.exec(bufferText)) {
        hasResults = true;
        lastIndex = re.lastIndex;
        res = match[0];
        startIndex = lastIndex - res.length;
        if (lastIndex > bufferEnd) {
          break;
        }
        re.lastIndex = this.extractVariableElements(res, startIndex, lastIndex, solver);
      }
      return Q.fcall(function() {
        return results;
      });
    };

    ColorVariablesParsing.extractVariableElements = function(string, startIndex, lastIndex, solver) {
      var block, k, key, m, re, regexp, value, _, _ref1, _ref2;
      _ref1 = this.variableExpressions;
      for (k in _ref1) {
        _ref2 = _ref1[k], regexp = _ref2.regexp, block = _ref2.block;
        re = new RegExp(regexp);
        m = re.exec(string);
        if (m != null) {
          if (block != null) {
            return block(m, startIndex, lastIndex, solver);
          } else {
            _ = m[0], key = m[1], value = m[2];
            solver.appendResult([key, value, startIndex, lastIndex]);
            return lastIndex;
          }
        }
      }
    };

    ColorVariablesParsing.getVariableExpressionsRegexp = function() {
      var k, regex, v;
      regex = ((function() {
        var _ref1, _results;
        _ref1 = this.variableExpressions;
        _results = [];
        for (k in _ref1) {
          v = _ref1[k];
          _results.push(v.regexp);
        }
        return _results;
      }).call(this)).join('|');
      return new RegExp("(" + regex + ")", 'gm');
    };

    return ColorVariablesParsing;

  })(Mixin);

}).call(this);
